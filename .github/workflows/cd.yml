name: Backend CD - Deploy

on:
  workflow_dispatch:
  push:
    branches:
      - main
      - dev

jobs:
  deploy:
    name: CD - Backend Deploy
    runs-on: self-hosted
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set deployment variables
        id: vars
        run: |
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "branch=main" >> $GITHUB_OUTPUT
            echo "db_name=${{ secrets.DB_NAME }}" >> $GITHUB_OUTPUT
            echo "allow_test_emails=false" >> $GITHUB_OUTPUT
            echo "server_user=${{ secrets.PROD_USER }}" >> $GITHUB_OUTPUT
            echo "server_ip=${{ secrets.PROD_IP }}" >> $GITHUB_OUTPUT
            echo "server_pass=${{ secrets.PROD_PASS }}" >> $GITHUB_OUTPUT
            echo "remote_dir=/home/ifeanyinw/apps/backend/legal-watch-dog-be" >> $GITHUB_OUTPUT
            echo "repo_url=https://github.com/hngprojects/legal-watch-dog-be.git" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "branch=dev" >> $GITHUB_OUTPUT
            echo "db_name=${{ secrets.STAGING_DB_NAME }}" >> $GITHUB_OUTPUT
            echo "allow_test_emails=true" >> $GITHUB_OUTPUT
            echo "server_user=${{ secrets.STAGING_USER }}" >> $GITHUB_OUTPUT
            echo "server_ip=${{ secrets.STAGING_IP }}" >> $GITHUB_OUTPUT
            echo "server_pass=${{ secrets.STAGING_PASS }}" >> $GITHUB_OUTPUT
            echo "remote_dir=/home/ubuntu/apps/backend/ec2-for-tasing-" >> $GITHUB_OUTPUT
            echo "repo_url=https://github.com/PreciousEzeigbo/legal-watch-dog-be.git" >> $GITHUB_OUTPUT
          fi

      - name: Generate environment file
        run: |
          cat <<EOF > .env.${{ steps.vars.outputs.environment }}
          DEBUG=False
          APP_PORT="${{ secrets.APP_PORT || vars.APP_PORT || '8001' }}"
          APP_NAME="${{ vars.APP_NAME || 'LEGAL WATCH DOG' }}"
          APP_VERSION="${{ vars.APP_VERSION || '1.0.0' }}"
          ENVIRONMENT="${{ steps.vars.outputs.environment }}"
          SECRET_KEY="${{ secrets.SECRET_KEY }}"
          LEGAL_WATCH_DOG_BASE_URL="${{ secrets.BASE_URL || vars.BASE_URL }}"

          DB_TYPE="${{ vars.DB_TYPE || 'postgresql' }}"
          DB_HOST="${{ secrets.DB_HOST }}"
          DB_PORT="${{ secrets.DB_PORT }}"
          DB_USER="${{ secrets.DB_USER }}"
          DB_PASS="${{ secrets.DB_PASS }}"
          DB_NAME="${{ steps.vars.outputs.db_name }}"
          DATABASE_URL="postgresql+asyncpg://${{ secrets.DB_USER }}:${{ secrets.DB_PASS }}@${{ secrets.DB_HOST }}/${{ steps.vars.outputs.db_name }}"

          MAIL_MAILER="${{ vars.MAIL_MAILER || 'smtp' }}"
          SMTP_SERVER="${{ secrets.SMTP_SERVER }}"
          SMTP_PORT="${{ secrets.SMTP_PORT }}"
          MAIL_USERNAME="${{ secrets.MAIL_USERNAME }}"
          MAIL_PASSWORD="${{ secrets.MAIL_PASSWORD }}"
          MAIL_ENCRYPTION="${{ secrets.MAIL_ENCRYPTION }}"
          EMAIL="${{ secrets.EMAIL }}"
          MAIL_FROM_NAME="${{ vars.MAIL_FROM_NAME || 'LEGAL WATCH DOG' }}"

          APP_URL="${{ vars.APP_URL || 'https://minamoto.emerj.net' }}"
          DEV_URL="${{ vars.DEV_URL || 'http://localhost:3000' }}"
          REDIS_URL="${{ secrets.REDIS_URL }}"
          REDIS_CACHE_TTL_SECONDS="${{ secrets.REDIS_CACHE_TTL_SECONDS }}"
          JWT_SECRET="${{ secrets.JWT_SECRET }}"
          JWT_ALGORITHM="${{ secrets.JWT_ALGORITHM }}"
          JWT_EXPIRY="${{ secrets.JWT_EXPIRY }}"
          ACCESS_TOKEN_EXPIRATION="${{ secrets.ACCESS_TOKEN_EXPIRATION }}"

          ALLOW_TEST_EMAIL_PROVIDERS="${{ steps.vars.outputs.allow_test_emails }}"
          TEST_EMAIL_PROVIDERS="${{ vars.TEST_EMAIL_PROVIDERS || 'gmail.com' }}"
          ENCRYPTION_KEY="${{ secrets.ENCRYPTION_KEY }}"
          EOF

      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Upload .env file to server
        run: |
          sshpass -p "${{ steps.vars.outputs.server_pass }}" scp -o StrictHostKeyChecking=no \
            .env.${{ steps.vars.outputs.environment }} \
            ${{ steps.vars.outputs.server_user }}@${{ steps.vars.outputs.server_ip }}:/tmp/backend_env

      - name: Deploy to server
        env:
          SERVER_PASS: ${{ steps.vars.outputs.server_pass }}
          SERVER_USER: ${{ steps.vars.outputs.server_user }}
          SERVER_IP: ${{ steps.vars.outputs.server_ip }}
          REMOTE_DIR: ${{ steps.vars.outputs.remote_dir }}
          REPO_URL: ${{ steps.vars.outputs.repo_url }}
          BRANCH: ${{ steps.vars.outputs.branch }}
          ENVIRONMENT: ${{ steps.vars.outputs.environment }}
        run: |
          echo "access gained"
          echo "deploying to $ENVIRONMENT server"

          sshpass -p "$SERVER_PASS" ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_IP << 'EOF'
            set -e

            REMOTE_DIR="${REMOTE_DIR}"
            REPO_URL="${REPO_URL}"
            BRANCH="${BRANCH}"
            
            # Clone if the directory doesn't exist
            if [ ! -d "$REMOTE_DIR" ]; then
              mkdir -p $(dirname "$REMOTE_DIR")
              git clone "$REPO_URL" "$REMOTE_DIR"
            fi

            cd "$REMOTE_DIR"
            
            git pull origin "$BRANCH"
            
            mv /tmp/backend_env .env
            
            # Install uv if not present
            if ! command -v uv &> /dev/null; then
              echo "Installing uv..."
              curl -LsSf https://astral.sh/uv/install.sh | sh
              export PATH="$HOME/.local/bin:$PATH"
            fi
            
            uv sync

            uv run alembic upgrade head
            
            # Load environment variables
            set -a 
            source .env 
            set +a
            
            # PM2 Management
            PM2_APP_NAME="legal-watchdog-be-${ENVIRONMENT}"
            
            # Check if PM2 is installed
            if ! command -v pm2 &> /dev/null; then
              echo "Installing PM2..."
              npm install -g pm2
            fi
            
            # Check if ecosystem.config.js exists
            if [ ! -f "ecosystem.config.js" ]; then
              echo "Error: ecosystem.config.js not found!"
              exit 1
            fi
            
            # Stop all existing PM2 processes for this app (if any)
            echo "Checking for existing PM2 processes..."
            pm2 describe "$PM2_APP_NAME" > /dev/null 2>&1 && pm2 delete "$PM2_APP_NAME" || echo "No existing process found"
            
            # Start/restart using ecosystem config
            echo "Starting application with ecosystem.config.js..."
            pm2 start ecosystem.config.js --update-env
            
            # Save PM2 process list to persist across reboots
            pm2 save
            
            # Setup PM2 startup script (safe to run multiple times)
            pm2 startup systemd -u $(whoami) --hp $(echo $HOME) || true
            
            echo "$ENVIRONMENT deployment complete on port $APP_PORT!"
            pm2 status
          EOF

  notify_slack:
    name: Notify Slack
    runs-on: self-hosted
    needs: [deploy]
    if: always()

    steps:
      - name: Send Slack Notification
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          DEPLOY_RESULT: ${{ needs.deploy.result }}
        run: |
          echo "Preparing Slack message..."

          # Get branch name
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          
          # Determine environment
          if [ "$BRANCH_NAME" == "main" ]; then
            ENV_NAME="Production"
            ENV_EMOJI="üöÄ"
          else
            ENV_NAME="Staging"
            ENV_EMOJI="üß™"
          fi
          
          # Determine outcome and set appropriate emoji
          if [ "$DEPLOY_RESULT" == "success" ]; then
            MAIN_STATUS="‚úÖ Deployment Successful"
            STATUS_COLOR="good"
            DETAIL_MSG="\n‚úÖ *${ENV_NAME} Environment:* Successfully deployed to ${ENV_NAME,,} server"
          else
            MAIN_STATUS="‚ùå Deployment Failed"
            STATUS_COLOR="danger"
            DETAIL_MSG="\n‚ùå *${ENV_NAME} Environment:* Failed to deploy to ${ENV_NAME,,} server"
          fi

          # Add branch info
          DETAIL_MSG="${DETAIL_MSG}\n\n${ENV_EMOJI} *Environment:* \`${ENV_NAME}\`"
          DETAIL_MSG="${DETAIL_MSG}\nüìã *Branch:* \`${BRANCH_NAME}\`"
          DETAIL_MSG="${DETAIL_MSG}\nüë§ *Triggered by:* ${GITHUB_ACTOR}"

          LOG_LINK="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          # Format Slack JSON with rich formatting
          PAYLOAD="{
            \"attachments\": [
              {
                \"color\": \"${STATUS_COLOR}\",
                \"blocks\": [
                  {
                    \"type\": \"header\",
                    \"text\": {
                      \"type\": \"plain_text\",
                      \"text\": \"‚öôÔ∏è Backend Deployment Update\",
                      \"emoji\": true
                    }
                  },
                  {
                    \"type\": \"section\",
                    \"text\": {
                      \"type\": \"mrkdwn\",
                      \"text\": \"*${MAIN_STATUS}*${DETAIL_MSG}\"
                    }
                  },
                  {
                    \"type\": \"divider\"
                  },
                  {
                    \"type\": \"section\",
                    \"text\": {
                      \"type\": \"mrkdwn\",
                      \"text\": \"Need help? Check the <${LOG_LINK}|detailed logs> or contact the development team.\"
                    }
                  }
                ]
              }
            ]
          }"

          curl -X POST -H 'Content-type: application/json' --data "$PAYLOAD" $SLACK_WEBHOOK
