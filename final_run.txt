============================= test session starts =============================
platform win32 -- Python 3.12.6, pytest-9.0.1, pluggy-1.6.0 -- C:\Users\DanielsFega\legal-watch-dog-be\.venv\Scripts\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\DanielsFega\legal-watch-dog-be
configfile: pyproject.toml
plugins: anyio-4.11.0, asyncio-1.3.0, cov-7.0.0, env-1.2.0, xdist-3.8.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 14 items

tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_sends_emails_success FAILED [  7%]
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_only_creator FAILED [ 14%]
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_multiple_project_users PASSED [ 21%]
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_duplicate_user_handling FAILED [ 28%]
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_idempotency PASSED [ 35%]
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_retry_failed PASSED [ 42%]
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_email_failure PASSED [ 50%]
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_email_exception PASSED [ 57%]
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_not_found PASSED [ 64%]
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_missing_user FAILED [ 71%]
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_invalid_uuid PASSED [ 78%]
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_empty_message FAILED [ 85%]
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_email_context FAILED [ 92%]
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_different_statuses FAILED [100%]

================================== FAILURES ===================================
________________ test_ticket_notification_sends_emails_success ________________

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x0000019422A2D120>
operation = 'INSERT INTO organizations (id, name, industry, location, plan, logo_url, settings, billing_info, is_active, created_a...N, $8::JSON, $9::BOOLEAN, $10::TIMESTAMP WITH TIME ZONE, $11::TIMESTAMP WITH TIME ZONE, $12::TIMESTAMP WITH TIME ZONE)'
parameters = (UUID('8ed8685e-389e-4b22-be9d-76705020a7b3'), 'Test Org', None, None, None, None, ...)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection
    
        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()
    
            if parameters is None:
                parameters = ()
    
            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )
    
                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None
    
                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:550: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\asyncpg\prepared_stmt.py:176: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\prepared_stmt.py:267: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv\Lib\site-packages\asyncpg\prepared_stmt.py:256: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.UniqueViolationError: duplicate key value violates unique constraint "organizations_pkey"
E   DETAIL:  Key (id)=(8ed8685e-389e-4b22-be9d-76705020a7b3) already exists.

asyncpg\\protocol\\protocol.pyx:206: UniqueViolationError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x0000019422A1AC30>
dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x000001942244AF60>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x0000019422A44DA0>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x0000019422A441D0>
parameters = [(UUID('8ed8685e-389e-4b22-be9d-76705020a7b3'), 'Test Org', None, None, None, None, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x00000194223BB7A0>>
error = UniqueViolationError('duplicate key value violates unique constraint "organizations_pkey"')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.IntegrityError: <class 'asyncpg.exceptions.UniqueViolationError'>: duplicate key value violates unique constraint "organizations_pkey"
E                   DETAIL:  Key (id)=(8ed8685e-389e-4b22-be9d-76705020a7b3) already exists.

.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:797: IntegrityError

The above exception was the direct cause of the following exception:

async_session = <sqlmodel.ext.asyncio.session.AsyncSession object at 0x00000194222CDD00>

    @pytest.mark.asyncio
    async def test_ticket_notification_sends_emails_success(async_session):
        """
        Test that notifications are successfully sent to all relevant users:
        - Ticket creator
        - Assigned user
        - Project users
    
        Verifies that all notifications are created with SENT status and sent_at timestamp.
        """
        ticket_id = uuid4()
        org_id = uuid4()
        project_id = uuid4()
        # Create Organization and Project to satisfy foreign key constraints
        org = Organization(id=org_id, name="Test Org")
        project = Project(id=project_id, org_id=org_id, title="Test Project")
    
        async_session.add_all([org, project])
        await async_session.commit()
    
    
        # Create Organization and Project to satisfy foreign key constraints
        org = Organization(id=org_id, name="Test Org")
        project = Project(id=project_id, org_id=org_id, title="Test Project")
    
        async_session.add_all([org, project])
>       await async_session.commit()

tests\modules\v1\notifications\service\test_ticket_notification_services.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\session.py:1000: in commit
    await greenlet_spawn(self.sync_session.commit)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:2030: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1311: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1286: in _prepare_impl
    self.session.flush()
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4331: in flush
    self._flush(objects)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4427: in _flush
    flush_context.execute()
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:1048: in _emit_insert_statements
    result = connection.execute(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
.venv\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x00000194223BB7A0>>
error = UniqueViolationError('duplicate key value violates unique constraint "organizations_pkey"')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.IntegrityError: (sqlalchemy.dialects.postgresql.asyncpg.IntegrityError) <class 'asyncpg.exceptions.UniqueViolationError'>: duplicate key value violates unique constraint "organizations_pkey"
E                   DETAIL:  Key (id)=(8ed8685e-389e-4b22-be9d-76705020a7b3) already exists.
E                   [SQL: INSERT INTO organizations (id, name, industry, location, plan, logo_url, settings, billing_info, is_active, created_at, updated_at, deleted_at) VALUES ($1::UUID, $2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR, $7::JSON, $8::JSON, $9::BOOLEAN, $10::TIMESTAMP WITH TIME ZONE, $11::TIMESTAMP WITH TIME ZONE, $12::TIMESTAMP WITH TIME ZONE)]
E                   [parameters: (UUID('8ed8685e-389e-4b22-be9d-76705020a7b3'), 'Test Org', None, None, None, None, '{"visibility": "private", "require_strong_passwords": true, "require_2fa": true, "allow_external_sharing": false, "audit_logging_enabled": true, "project_default_privacy": "private"}', '{}', True, datetime.datetime(2025, 12, 5, 19, 6, 13, 224405, tzinfo=datetime.timezone.utc), datetime.datetime(2025, 12, 5, 19, 6, 13, 224405, tzinfo=datetime.timezone.utc), None)]
E                   (Background on this error at: https://sqlalche.me/e/20/gkpj)

.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:797: IntegrityError
____________________ test_ticket_notification_only_creator ____________________

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x0000019422B35180>
operation = 'INSERT INTO users (id, email, hashed_password, auth_provider, name, provider_user_id, profile_picture_url, provider_p...CHAR, $8::JSON, $9::VARCHAR, $10::BOOLEAN, $11::BOOLEAN, $12::TIMESTAMP WITH TIME ZONE, $13::TIMESTAMP WITH TIME ZONE)'
parameters = (UUID('c30fb9e4-a5c8-4078-83a0-699abe6220b3'), 'creator@test.com', None, 'local', None, None, ...)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection
    
        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()
    
            if parameters is None:
                parameters = ()
    
            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )
    
                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None
    
                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:550: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\asyncpg\prepared_stmt.py:176: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\prepared_stmt.py:267: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv\Lib\site-packages\asyncpg\prepared_stmt.py:256: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.NotNullViolationError: null value in column "name" of relation "users" violates not-null constraint
E   DETAIL:  Failing row contains (c30fb9e4-a5c8-4078-83a0-699abe6220b3, creator@test.com, null, local, null, null, null, null, null, t, f, 2025-12-05 07:06:16.516353-12, 2025-12-05 07:06:16.516353-12).

asyncpg\\protocol\\protocol.pyx:206: NotNullViolationError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x0000019422B5D3D0>
dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x0000019422B2F560>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x0000019422B5D490>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x0000019422B5CFE0>
parameters = [(UUID('c30fb9e4-a5c8-4078-83a0-699abe6220b3'), 'creator@test.com', None, 'local', None, None, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x0000019422C50F50>>
error = NotNullViolationError('null value in column "name" of relation "users" violates not-null constraint')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.IntegrityError: <class 'asyncpg.exceptions.NotNullViolationError'>: null value in column "name" of relation "users" violates not-null constraint
E                   DETAIL:  Failing row contains (c30fb9e4-a5c8-4078-83a0-699abe6220b3, creator@test.com, null, local, null, null, null, null, null, t, f, 2025-12-05 07:06:16.516353-12, 2025-12-05 07:06:16.516353-12).

.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:797: IntegrityError

The above exception was the direct cause of the following exception:

async_session = <sqlmodel.ext.asyncio.session.AsyncSession object at 0x00000194224D7500>

    @pytest.mark.asyncio
    async def test_ticket_notification_only_creator(async_session):
        """
        Test notification when ticket has only a creator (no assignee or project users).
    
        Verifies that a single notification is sent to the creator.
        """
        ticket_id = uuid4()
        org_id = uuid4()
        project_id = uuid4()
        # Create Organization and Project to satisfy foreign key constraints
        org = Organization(id=org_id, name="Test Org")
        project = Project(id=project_id, org_id=org_id, title="Test Project")
    
        async_session.add_all([org, project])
        await async_session.commit()
    
    
        creator = User(id=uuid4(), email="creator@test.com")
        async_session.add(creator)
>       await async_session.commit()

tests\modules\v1\notifications\service\test_ticket_notification_services.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\session.py:1000: in commit
    await greenlet_spawn(self.sync_session.commit)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:2030: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1311: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1286: in _prepare_impl
    self.session.flush()
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4331: in flush
    self._flush(objects)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4427: in _flush
    flush_context.execute()
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:1048: in _emit_insert_statements
    result = connection.execute(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
.venv\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x0000019422C50F50>>
error = NotNullViolationError('null value in column "name" of relation "users" violates not-null constraint')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.IntegrityError: (sqlalchemy.dialects.postgresql.asyncpg.IntegrityError) <class 'asyncpg.exceptions.NotNullViolationError'>: null value in column "name" of relation "users" violates not-null constraint
E                   DETAIL:  Failing row contains (c30fb9e4-a5c8-4078-83a0-699abe6220b3, creator@test.com, null, local, null, null, null, null, null, t, f, 2025-12-05 07:06:16.516353-12, 2025-12-05 07:06:16.516353-12).
E                   [SQL: INSERT INTO users (id, email, hashed_password, auth_provider, name, provider_user_id, profile_picture_url, provider_profile_data, avatar_url, is_active, is_verified, created_at, updated_at) VALUES ($1::UUID, $2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR, $7::VARCHAR, $8::JSON, $9::VARCHAR, $10::BOOLEAN, $11::BOOLEAN, $12::TIMESTAMP WITH TIME ZONE, $13::TIMESTAMP WITH TIME ZONE)]
E                   [parameters: (UUID('c30fb9e4-a5c8-4078-83a0-699abe6220b3'), 'creator@test.com', None, 'local', None, None, None, 'null', None, True, False, datetime.datetime(2025, 12, 5, 19, 6, 16, 516353, tzinfo=datetime.timezone.utc), datetime.datetime(2025, 12, 5, 19, 6, 16, 516353, tzinfo=datetime.timezone.utc))]
E                   (Background on this error at: https://sqlalche.me/e/20/gkpj)

.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:797: IntegrityError
______________ test_ticket_notification_duplicate_user_handling _______________

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x0000019423512EC0>
operation = 'INSERT INTO users (id, email, hashed_password, auth_provider, name, provider_user_id, profile_picture_url, provider_p...CHAR, $8::JSON, $9::VARCHAR, $10::BOOLEAN, $11::BOOLEAN, $12::TIMESTAMP WITH TIME ZONE, $13::TIMESTAMP WITH TIME ZONE)'
parameters = (UUID('46bccd5f-ef6a-4542-bd58-aa9161bfbd39'), 'creator@test.com', None, 'local', None, None, ...)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection
    
        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()
    
            if parameters is None:
                parameters = ()
    
            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )
    
                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None
    
                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:550: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\asyncpg\prepared_stmt.py:176: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\prepared_stmt.py:267: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv\Lib\site-packages\asyncpg\prepared_stmt.py:256: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.NotNullViolationError: null value in column "name" of relation "users" violates not-null constraint
E   DETAIL:  Failing row contains (46bccd5f-ef6a-4542-bd58-aa9161bfbd39, creator@test.com, null, local, null, null, null, null, null, t, f, 2025-12-05 07:08:28.53327-12, 2025-12-05 07:08:28.53327-12).

asyncpg\\protocol\\protocol.pyx:206: NotNullViolationError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x00000194234FAD50>
dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x00000194234FA900>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x000001942347FC20>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x000001942347FEC0>
parameters = [(UUID('46bccd5f-ef6a-4542-bd58-aa9161bfbd39'), 'creator@test.com', None, 'local', None, None, ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x00000194236BAC60>>
error = NotNullViolationError('null value in column "name" of relation "users" violates not-null constraint')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.IntegrityError: <class 'asyncpg.exceptions.NotNullViolationError'>: null value in column "name" of relation "users" violates not-null constraint
E                   DETAIL:  Failing row contains (46bccd5f-ef6a-4542-bd58-aa9161bfbd39, creator@test.com, null, local, null, null, null, null, null, t, f, 2025-12-05 07:08:28.53327-12, 2025-12-05 07:08:28.53327-12).

.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:797: IntegrityError

The above exception was the direct cause of the following exception:

async_session = <sqlmodel.ext.asyncio.session.AsyncSession object at 0x0000019423504CE0>

    @pytest.mark.asyncio
    async def test_ticket_notification_duplicate_user_handling(async_session):
        """
        Test that duplicate users (e.g., creator is also a project user) receive only one notification.
    
        Verifies deduplication logic works correctly.
        """
        ticket_id = uuid4()
        org_id = uuid4()
        project_id = uuid4()
        # Create Organization and Project to satisfy foreign key constraints
        org = Organization(id=org_id, name="Test Org")
        project = Project(id=project_id, org_id=org_id, title="Test Project")
    
        async_session.add_all([org, project])
        await async_session.commit()
    
    
        creator = User(id=uuid4(), email="creator@test.com")
        async_session.add(creator)
>       await async_session.commit()

tests\modules\v1\notifications\service\test_ticket_notification_services.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\session.py:1000: in commit
    await greenlet_spawn(self.sync_session.commit)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:2030: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1311: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1286: in _prepare_impl
    self.session.flush()
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4331: in flush
    self._flush(objects)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4427: in _flush
    flush_context.execute()
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:1048: in _emit_insert_statements
    result = connection.execute(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
.venv\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x00000194236BAC60>>
error = NotNullViolationError('null value in column "name" of relation "users" violates not-null constraint')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.IntegrityError: (sqlalchemy.dialects.postgresql.asyncpg.IntegrityError) <class 'asyncpg.exceptions.NotNullViolationError'>: null value in column "name" of relation "users" violates not-null constraint
E                   DETAIL:  Failing row contains (46bccd5f-ef6a-4542-bd58-aa9161bfbd39, creator@test.com, null, local, null, null, null, null, null, t, f, 2025-12-05 07:08:28.53327-12, 2025-12-05 07:08:28.53327-12).
E                   [SQL: INSERT INTO users (id, email, hashed_password, auth_provider, name, provider_user_id, profile_picture_url, provider_profile_data, avatar_url, is_active, is_verified, created_at, updated_at) VALUES ($1::UUID, $2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::VARCHAR, $6::VARCHAR, $7::VARCHAR, $8::JSON, $9::VARCHAR, $10::BOOLEAN, $11::BOOLEAN, $12::TIMESTAMP WITH TIME ZONE, $13::TIMESTAMP WITH TIME ZONE)]
E                   [parameters: (UUID('46bccd5f-ef6a-4542-bd58-aa9161bfbd39'), 'creator@test.com', None, 'local', None, None, None, 'null', None, True, False, datetime.datetime(2025, 12, 5, 19, 8, 28, 533270, tzinfo=datetime.timezone.utc), datetime.datetime(2025, 12, 5, 19, 8, 28, 533270, tzinfo=datetime.timezone.utc))]
E                   (Background on this error at: https://sqlalche.me/e/20/gkpj)

.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:797: IntegrityError
____________________ test_ticket_notification_missing_user ____________________

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x0000019423497B20>
operation = 'INSERT INTO tickets (id, title, description, content, status, priority, is_manual, data_revision_id, source_id, creat...ID, $13::UUID, $14::UUID, $15::TIMESTAMP WITH TIME ZONE, $16::TIMESTAMP WITH TIME ZONE, $17::TIMESTAMP WITH TIME ZONE)'
parameters = (UUID('53377cea-15d0-49cb-ab17-6bf2a74e02d4'), 'Missing User Test', None, None, 'OPEN', 'MEDIUM', ...)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection
    
        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()
    
            if parameters is None:
                parameters = ()
    
            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )
    
                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None
    
                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
>                   self._rows = deque(await prepared_stmt.fetch(*parameters))
                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:550: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\asyncpg\prepared_stmt.py:176: in fetch
    data = await self.__bind_execute(args, 0, timeout)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\asyncpg\prepared_stmt.py:267: in __bind_execute
    data, status, _ = await self.__do_execute(
.venv\Lib\site-packages\asyncpg\prepared_stmt.py:256: in __do_execute
    return await executor(protocol)
           ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

>   ???
E   asyncpg.exceptions.ForeignKeyViolationError: insert or update on table "tickets" violates foreign key constraint "tickets_created_by_user_id_fkey"
E   DETAIL:  Key (created_by_user_id)=(ac7b985e-99a1-4e1a-a329-8dee97c7b1a9) is not present in table "users".

asyncpg\\protocol\\protocol.pyx:206: ForeignKeyViolationError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x00000194241F67E0>
dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x000001942426BE60>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x0000019423F80650>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x0000019423F81DF0>
parameters = [(UUID('53377cea-15d0-49cb-ab17-6bf2a74e02d4'), 'Missing User Test', None, None, 'OPEN', 'MEDIUM', ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x0000019422C58B90>>
error = ForeignKeyViolationError('insert or update on table "tickets" violates foreign key constraint "tickets_created_by_user_id_fkey"')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.IntegrityError: <class 'asyncpg.exceptions.ForeignKeyViolationError'>: insert or update on table "tickets" violates foreign key constraint "tickets_created_by_user_id_fkey"
E                   DETAIL:  Key (created_by_user_id)=(ac7b985e-99a1-4e1a-a329-8dee97c7b1a9) is not present in table "users".

.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:797: IntegrityError

The above exception was the direct cause of the following exception:

async_session = <sqlmodel.ext.asyncio.session.AsyncSession object at 0x00000194241A0A70>

    @pytest.mark.asyncio
    async def test_ticket_notification_missing_user(async_session):
        """
        Test that notifications are skipped for users that don't exist.
    
        Verifies that the service handles missing user records gracefully.
        """
        ticket_id = uuid4()
        org_id = uuid4()
        project_id = uuid4()
        # Create Organization and Project to satisfy foreign key constraints
        org = Organization(id=org_id, name="Test Org")
        project = Project(id=project_id, org_id=org_id, title="Test Project")
    
        async_session.add_all([org, project])
        await async_session.commit()
    
    
        # Create a user that we'll reference but then delete
        temp_user = User(id=uuid4(), email="temp@test.com", name="Temp User")
        async_session.add(temp_user)
        await async_session.commit()
    
        user_id = temp_user.id
    
        # Delete the user
        await async_session.delete(temp_user)
        await async_session.commit()
    
        # Create ticket referencing the deleted user
        ticket = Ticket(
            id=ticket_id,
            title="Missing User Test",
            status=TicketStatus.OPEN,
            created_by_user_id=user_id,
            organization_id=org_id,
            project_id=project_id,
        )
    
        async_session.add(ticket)
>       await async_session.commit()

tests\modules\v1\notifications\service\test_ticket_notification_services.py:560: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\ext\asyncio\session.py:1000: in commit
    await greenlet_spawn(self.sync_session.commit)
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:203: in greenlet_spawn
    result = context.switch(value)
             ^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:2030: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1311: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1286: in _prepare_impl
    self.session.flush()
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4331: in flush
    self._flush(objects)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4427: in _flush
    flush_context.execute()
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:1048: in _emit_insert_statements
    result = connection.execute(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
.venv\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
.venv\Lib\site-packages\sqlalchemy\engine\default.py:951: in do_execute
    cursor.execute(statement, parameters)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:585: in execute
    self._adapt_connection.await_(
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:132: in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\_concurrency_py3k.py:196: in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:563: in _prepare_and_execute
    self._handle_exception(error)
.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:513: in _handle_exception
    self._adapt_connection._handle_exception(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x0000019422C58B90>>
error = ForeignKeyViolationError('insert or update on table "tickets" violates foreign key constraint "tickets_created_by_user_id_fkey"')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.IntegrityError: (sqlalchemy.dialects.postgresql.asyncpg.IntegrityError) <class 'asyncpg.exceptions.ForeignKeyViolationError'>: insert or update on table "tickets" violates foreign key constraint "tickets_created_by_user_id_fkey"
E                   DETAIL:  Key (created_by_user_id)=(ac7b985e-99a1-4e1a-a329-8dee97c7b1a9) is not present in table "users".
E                   [SQL: INSERT INTO tickets (id, title, description, content, status, priority, is_manual, data_revision_id, source_id, created_by_user_id, assigned_by_user_id, assigned_to_user_id, organization_id, project_id, created_at, updated_at, closed_at) VALUES ($1::UUID, $2::VARCHAR, $3::VARCHAR, $4::VARCHAR, $5::ticketstatus, $6::ticketpriority, $7::BOOLEAN, $8::UUID, $9::UUID, $10::UUID, $11::UUID, $12::UUID, $13::UUID, $14::UUID, $15::TIMESTAMP WITH TIME ZONE, $16::TIMESTAMP WITH TIME ZONE, $17::TIMESTAMP WITH TIME ZONE)]
E                   [parameters: (UUID('53377cea-15d0-49cb-ab17-6bf2a74e02d4'), 'Missing User Test', None, None, 'OPEN', 'MEDIUM', True, None, None, UUID('ac7b985e-99a1-4e1a-a329-8dee97c7b1a9'), None, None, UUID('be36a2d3-a7db-403b-ad1f-1758fbdb108f'), UUID('1e65ff11-3500-4d57-b3e6-408c98cea20c'), datetime.datetime(2025, 12, 5, 19, 9, 41, 217366, tzinfo=datetime.timezone.utc), datetime.datetime(2025, 12, 5, 19, 9, 41, 217366, tzinfo=datetime.timezone.utc), None)]
E                   (Background on this error at: https://sqlalche.me/e/20/gkpj)

.venv\Lib\site-packages\sqlalchemy\dialects\postgresql\asyncpg.py:797: IntegrityError
___________________ test_ticket_notification_empty_message ____________________

async_session = <sqlmodel.ext.asyncio.session.AsyncSession object at 0x0000019422B8DA00>

    @pytest.mark.asyncio
    async def test_ticket_notification_empty_message(async_session):
        """
        Test that notifications can be sent with empty message.
    
        Verifies that empty messages are handled (though not recommended).
        """
        ticket_id = uuid4()
        org_id = uuid4()
        project_id = uuid4()
        # Create Organization and Project to satisfy foreign key constraints
        org = Organization(id=org_id, name="Test Org")
        project = Project(id=project_id, org_id=org_id, title="Test Project")
    
        async_session.add_all([org, project])
        await async_session.commit()
    
    
        user = User(id=uuid4(), email="empty@test.com", name="Empty User")
        async_session.add(user)
        await async_session.commit()
    
        ticket = Ticket(
            id=ticket_id,
            title="Empty Message Test",
            status=TicketStatus.OPEN,
            created_by_user_id=user.id,
            organization_id=org_id,
            project_id=project_id,
        )
    
        async_session.add(ticket)
        await async_session.commit()
    
        with patch(
            "app.api.core.dependencies.send_mail.send_email", new=AsyncMock(return_value=True)
        ):
            await send_ticket_notifications(str(ticket_id), "", session=async_session)
    
        result = await async_session.execute(select(TicketNotification))
        notif = result.scalar_one()
    
        assert notif.message == ""
>       assert notif.status == TicketNotificationStatus.SENT
E       AssertionError: assert <TicketNotifi...LED: 'FAILED'> == <TicketNotifi....SENT: 'SENT'>
E         
E         - SENT
E         + FAILED

tests\modules\v1\notifications\service\test_ticket_notification_services.py:633: AssertionError
---------------------------- Captured stderr call -----------------------------
2025-12-05 20:10:05,164 [ERROR] app send_mail:52 ù Failed to send email to empty@test.com: Error connecting to work.timbu.cloud on port 587: [WinError 121] The semaphore timeout period has expired
Traceback (most recent call last):
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 503, in _create_connection
    transport, _ = await asyncio.wait_for(connect_coro, timeout=timeout)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Python312\Lib\asyncio\tasks.py", line 520, in wait_for
    return await fut
           ^^^^^^^^^
  File "C:\Python312\Lib\asyncio\base_events.py", line 1121, in create_connection
    raise exceptions[0]
  File "C:\Python312\Lib\asyncio\base_events.py", line 1103, in create_connection
    sock = await self._connect_sock(
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Python312\Lib\asyncio\base_events.py", line 1006, in _connect_sock
    await self.sock_connect(sock, address)
  File "C:\Python312\Lib\asyncio\proactor_events.py", line 729, in sock_connect
    return await self._proactor.connect(sock, address)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Python312\Lib\asyncio\windows_events.py", line 803, in _poll
    value = callback(transferred, key, ov)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Python312\Lib\asyncio\windows_events.py", line 599, in finish_connect
    ov.getresult()
OSError: [WinError 121] The semaphore timeout period has expired

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "C:\Users\DanielsFega\legal-watch-dog-be\app\api\core\dependencies\send_mail.py", line 39, in send_email
    await aiosmtplib.send(
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\api.py", line 124, in send
    async with client:
               ^^^^^^
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 178, in __aenter__
    await self.connect()
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 453, in connect
    raise exc
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 446, in connect
    response = await self._create_connection(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 509, in _create_connection
    raise SMTPConnectError(
aiosmtplib.errors.SMTPConnectError: Error connecting to work.timbu.cloud on port 587: [WinError 121] The semaphore timeout period has expired
___________________ test_ticket_notification_email_context ____________________

async_session = <sqlmodel.ext.asyncio.session.AsyncSession object at 0x00000194239B9BB0>

    @pytest.mark.asyncio
    async def test_ticket_notification_email_context(async_session):
        """
        Test that email is called with correct context parameters.
    
        Verifies that the email template receives proper ticket information.
        """
        ticket_id = uuid4()
        org_id = uuid4()
        project_id = uuid4()
        # Create Organization and Project to satisfy foreign key constraints
        org = Organization(id=org_id, name="Test Org")
        project = Project(id=project_id, org_id=org_id, title="Test Project")
    
        async_session.add_all([org, project])
        await async_session.commit()
    
    
        user = User(id=uuid4(), email="context@test.com", name="Context User")
        async_session.add(user)
        await async_session.commit()
    
        ticket = Ticket(
            id=ticket_id,
            title="Context Test Ticket",
            status=TicketStatus.IN_PROGRESS,
            created_by_user_id=user.id,
            organization_id=org_id,
            project_id=project_id,
        )
    
        async_session.add(ticket)
        await async_session.commit()
    
        with patch(
            "app.api.core.dependencies.send_mail.send_email", new=AsyncMock(return_value=True)
        ) as mock_email:
            await send_ticket_notifications(str(ticket_id), "Test activity", session=async_session)
    
            # Verify email was called with correct parameters
>           mock_email.assert_called_once()

tests\modules\v1\notifications\service\test_ticket_notification_services.py:679: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AsyncMock id='1735764380032'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to have been called once. Called 0 times.

C:\Python312\Lib\unittest\mock.py:926: AssertionError
---------------------------- Captured stderr call -----------------------------
2025-12-05 20:10:27,349 [ERROR] app send_mail:52 ù Failed to send email to context@test.com: Error connecting to work.timbu.cloud on port 587: [WinError 121] The semaphore timeout period has expired
Traceback (most recent call last):
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 503, in _create_connection
    transport, _ = await asyncio.wait_for(connect_coro, timeout=timeout)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Python312\Lib\asyncio\tasks.py", line 520, in wait_for
    return await fut
           ^^^^^^^^^
  File "C:\Python312\Lib\asyncio\base_events.py", line 1121, in create_connection
    raise exceptions[0]
  File "C:\Python312\Lib\asyncio\base_events.py", line 1103, in create_connection
    sock = await self._connect_sock(
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Python312\Lib\asyncio\base_events.py", line 1006, in _connect_sock
    await self.sock_connect(sock, address)
  File "C:\Python312\Lib\asyncio\proactor_events.py", line 729, in sock_connect
    return await self._proactor.connect(sock, address)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Python312\Lib\asyncio\windows_events.py", line 803, in _poll
    value = callback(transferred, key, ov)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Python312\Lib\asyncio\windows_events.py", line 599, in finish_connect
    ov.getresult()
OSError: [WinError 121] The semaphore timeout period has expired

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "C:\Users\DanielsFega\legal-watch-dog-be\app\api\core\dependencies\send_mail.py", line 39, in send_email
    await aiosmtplib.send(
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\api.py", line 124, in send
    async with client:
               ^^^^^^
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 178, in __aenter__
    await self.connect()
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 453, in connect
    raise exc
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 446, in connect
    response = await self._create_connection(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 509, in _create_connection
    raise SMTPConnectError(
aiosmtplib.errors.SMTPConnectError: Error connecting to work.timbu.cloud on port 587: [WinError 121] The semaphore timeout period has expired
_________________ test_ticket_notification_different_statuses _________________

async_session = <sqlmodel.ext.asyncio.session.AsyncSession object at 0x0000019422451760>

    @pytest.mark.asyncio
    async def test_ticket_notification_different_statuses(async_session):
        """
        Test notifications for tickets with different statuses.
    
        Verifies that ticket status is correctly passed to email context.
        """
        org_id = uuid4()
        project_id = uuid4()
        # Create Organization and Project to satisfy foreign key constraints
        org = Organization(id=org_id, name="Test Org")
        project = Project(id=project_id, org_id=org_id, title="Test Project")
    
        async_session.add_all([org, project])
        await async_session.commit()
    
    
        user = User(id=uuid4(), email="status@test.com", name="Status User")
        async_session.add(user)
        await async_session.commit()
    
        # Only use valid statuses: OPEN, IN_PROGRESS, CLOSED (RESOLVED doesn't exist)
        statuses = [TicketStatus.OPEN, TicketStatus.IN_PROGRESS, TicketStatus.CLOSED]
    
        for status in statuses:
            ticket_id = uuid4()
            ticket = Ticket(
                id=ticket_id,
                title=f"Ticket {status.value}",
                status=status,
                created_by_user_id=user.id,
                organization_id=org_id,
                project_id=project_id,
            )
    
            async_session.add(ticket)
            await async_session.commit()
    
            with patch(
                "app.api.core.dependencies.send_mail.send_email", new=AsyncMock(return_value=True)
            ) as mock_email:
                await send_ticket_notifications(str(ticket_id), f"Status: {status.value}", session=async_session)
    
>               call_kwargs = mock_email.call_args.kwargs
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E               AttributeError: 'NoneType' object has no attribute 'kwargs'

tests\modules\v1\notifications\service\test_ticket_notification_services.py:733: AttributeError
---------------------------- Captured stderr call -----------------------------
2025-12-05 20:10:50,297 [ERROR] app send_mail:52 ù Failed to send email to status@test.com: Error connecting to work.timbu.cloud on port 587: [WinError 121] The semaphore timeout period has expired
Traceback (most recent call last):
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 503, in _create_connection
    transport, _ = await asyncio.wait_for(connect_coro, timeout=timeout)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Python312\Lib\asyncio\tasks.py", line 520, in wait_for
    return await fut
           ^^^^^^^^^
  File "C:\Python312\Lib\asyncio\base_events.py", line 1121, in create_connection
    raise exceptions[0]
  File "C:\Python312\Lib\asyncio\base_events.py", line 1103, in create_connection
    sock = await self._connect_sock(
           ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Python312\Lib\asyncio\base_events.py", line 1006, in _connect_sock
    await self.sock_connect(sock, address)
  File "C:\Python312\Lib\asyncio\proactor_events.py", line 729, in sock_connect
    return await self._proactor.connect(sock, address)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Python312\Lib\asyncio\windows_events.py", line 803, in _poll
    value = callback(transferred, key, ov)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Python312\Lib\asyncio\windows_events.py", line 599, in finish_connect
    ov.getresult()
OSError: [WinError 121] The semaphore timeout period has expired

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "C:\Users\DanielsFega\legal-watch-dog-be\app\api\core\dependencies\send_mail.py", line 39, in send_email
    await aiosmtplib.send(
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\api.py", line 124, in send
    async with client:
               ^^^^^^
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 178, in __aenter__
    await self.connect()
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 453, in connect
    raise exc
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 446, in connect
    response = await self._create_connection(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\aiosmtplib\smtp.py", line 509, in _create_connection
    raise SMTPConnectError(
aiosmtplib.errors.SMTPConnectError: Error connecting to work.timbu.cloud on port 587: [WinError 121] The semaphore timeout period has expired
============================== warnings summary ===============================
app\api\modules\v1\scraping\schemas\source_service.py:115
  C:\Users\DanielsFega\legal-watch-dog-be\app\api\modules\v1\scraping\schemas\source_service.py:115: PydanticDeprecatedSince20: `min_items` is deprecated and will be removed, use `min_length` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    sources: List[SourceCreate] = Field(..., min_items=1, max_items=50)

app\api\modules\v1\scraping\schemas\source_service.py:115
  C:\Users\DanielsFega\legal-watch-dog-be\app\api\modules\v1\scraping\schemas\source_service.py:115: PydanticDeprecatedSince20: `max_items` is deprecated and will be removed, use `max_length` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.12/migration/
    sources: List[SourceCreate] = Field(..., min_items=1, max_items=50)

.venv\Lib\site-packages\_pytest\config\__init__.py:1397
  C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\_pytest\config\__init__.py:1397: PytestConfigWarning: Unknown config option: env_files
  
    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")

.venv\Lib\site-packages\_pytest\config\__init__.py:1397
  C:\Users\DanielsFega\legal-watch-dog-be\.venv\Lib\site-packages\_pytest\config\__init__.py:1397: PytestConfigWarning: Unknown config option: env_override_existing_values
  
    self._warn_or_fail_if_strict(f"Unknown config option: {key}\n")

tests/modules/v1/notifications/service/test_ticket_notification_services.py: 14 warnings
  C:\\Users\\DanielsFega\\legal-watch-dog-be\\tests\\conftest.py:260: DeprecationWarning: \n          \U0001f6a8 You probably want to use `session.exec()` instead of `session.execute()`.\n  \n          This is the original SQLAlchemy `session.execute()` method that returns objects\n          of type `Row`, and that you have to call `scalars()` to get the model objects.\n  \n          For example:\n  \n          ```Python\n          heroes = await session.execute(select(Hero)).scalars().all()\n          ```\n  \n          instead you could use `exec()`:\n  \n          ```Python\n          heroes = await session.exec(select(Hero)).all()\n          ```\n          \n    result = await session.execute(

tests/modules/v1/notifications/service/test_ticket_notification_services.py: 14 warnings
  C:\\Users\\DanielsFega\\legal-watch-dog-be\\tests\\conftest.py:273: DeprecationWarning: \n          \U0001f6a8 You probably want to use `session.exec()` instead of `session.execute()`.\n  \n          This is the original SQLAlchemy `session.execute()` method that returns objects\n          of type `Row`, and that you have to call `scalars()` to get the model objects.\n  \n          For example:\n  \n          ```Python\n          heroes = await session.execute(select(Hero)).scalars().all()\n          ```\n  \n          instead you could use `exec()`:\n  \n          ```Python\n          heroes = await session.exec(select(Hero)).all()\n          ```\n          \n    await session.execute(text(f"TRUNCATE TABLE {tables_str} RESTART IDENTITY CASCADE"))

tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_multiple_project_users
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_idempotency
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_retry_failed
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_email_failure
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_email_exception
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_not_found
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_empty_message
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_email_context
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_different_statuses
  C:\\Users\\DanielsFega\\legal-watch-dog-be\\app\\api\\modules\\v1\\notifications\\service\\ticket_notification_service.py:36: DeprecationWarning: \n          \U0001f6a8 You probably want to use `session.exec()` instead of `session.execute()`.\n  \n          This is the original SQLAlchemy `session.execute()` method that returns objects\n          of type `Row`, and that you have to call `scalars()` to get the model objects.\n  \n          For example:\n  \n          ```Python\n          heroes = await session.execute(select(Hero)).scalars().all()\n          ```\n  \n          instead you could use `exec()`:\n  \n          ```Python\n          heroes = await session.exec(select(Hero)).all()\n          ```\n          \n    ticket_result = await session.execute(select(Ticket).where(Ticket.id == ticket_uuid))

tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_multiple_project_users
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_idempotency
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_retry_failed
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_email_failure
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_email_exception
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_empty_message
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_email_context
tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_different_statuses
  C:\\Users\\DanielsFega\\legal-watch-dog-be\\app\\api\\modules\\v1\\notifications\\service\\ticket_notification_service.py:44: DeprecationWarning: \n          \U0001f6a8 You probably want to use `session.exec()` instead of `session.execute()`.\n  \n          This is the original SQLAlchemy `session.execute()` method that returns objects\n          of type `Row`, and that you have to call `scalars()` to get the model objects.\n  \n          For example:\n  \n          ```Python\n          heroes = await session.execute(select(Hero)).scalars().all()\n          ```\n  \n          instead you could use `exec()`:\n  \n          ```Python\n          heroes = await session.exec(select(Hero)).all()\n          ```\n          \n    project_users_result = await session.execute(

tests/modules/v1/notifications/service/test_ticket_notification_services.py: 12 warnings
  C:\\Users\\DanielsFega\\legal-watch-dog-be\\app\\api\\modules\\v1\\notifications\\service\\ticket_notification_service.py:58: DeprecationWarning: \n          \U0001f6a8 You probably want to use `session.exec()` instead of `session.execute()`.\n  \n          This is the original SQLAlchemy `session.execute()` method that returns objects\n          of type `Row`, and that you have to call `scalars()` to get the model objects.\n  \n          For example:\n  \n          ```Python\n          heroes = await session.execute(select(Hero)).scalars().all()\n          ```\n  \n          instead you could use `exec()`:\n  \n          ```Python\n          heroes = await session.exec(select(Hero)).all()\n          ```\n          \n    user_result = await session.execute(select(User).where(User.id == user_id))

tests/modules/v1/notifications/service/test_ticket_notification_services.py: 12 warnings
  C:\\Users\\DanielsFega\\legal-watch-dog-be\\app\\api\\modules\\v1\\notifications\\service\\ticket_notification_service.py:64: DeprecationWarning: \n          \U0001f6a8 You probably want to use `session.exec()` instead of `session.execute()`.\n  \n          This is the original SQLAlchemy `session.execute()` method that returns objects\n          of type `Row`, and that you have to call `scalars()` to get the model objects.\n  \n          For example:\n  \n          ```Python\n          heroes = await session.execute(select(Hero)).scalars().all()\n          ```\n  \n          instead you could use `exec()`:\n  \n          ```Python\n          heroes = await session.exec(select(Hero)).all()\n          ```\n          \n    existing_result = await session.execute(

tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_multiple_project_users
  C:\\Users\\DanielsFega\\legal-watch-dog-be\\tests\\modules\\v1\\notifications\\service\\test_ticket_notification_services.py:207: DeprecationWarning: \n          \U0001f6a8 You probably want to use `session.exec()` instead of `session.execute()`.\n  \n          This is the original SQLAlchemy `session.execute()` method that returns objects\n          of type `Row`, and that you have to call `scalars()` to get the model objects.\n  \n          For example:\n  \n          ```Python\n          heroes = await session.execute(select(Hero)).scalars().all()\n          ```\n  \n          instead you could use `exec()`:\n  \n          ```Python\n          heroes = await session.exec(select(Hero)).all()\n          ```\n          \n    result = await async_session.execute(

tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_idempotency
  C:\\Users\\DanielsFega\\legal-watch-dog-be\\tests\\modules\\v1\\notifications\\service\\test_ticket_notification_services.py:332: DeprecationWarning: \n          \U0001f6a8 You probably want to use `session.exec()` instead of `session.execute()`.\n  \n          This is the original SQLAlchemy `session.execute()` method that returns objects\n          of type `Row`, and that you have to call `scalars()` to get the model objects.\n  \n          For example:\n  \n          ```Python\n          heroes = await session.execute(select(Hero)).scalars().all()\n          ```\n  \n          instead you could use `exec()`:\n  \n          ```Python\n          heroes = await session.exec(select(Hero)).all()\n          ```\n          \n    result = await async_session.execute(

tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_retry_failed
  C:\\Users\\DanielsFega\\legal-watch-dog-be\\tests\\modules\\v1\\notifications\\service\\test_ticket_notification_services.py:396: DeprecationWarning: \n          \U0001f6a8 You probably want to use `session.exec()` instead of `session.execute()`.\n  \n          This is the original SQLAlchemy `session.execute()` method that returns objects\n          of type `Row`, and that you have to call `scalars()` to get the model objects.\n  \n          For example:\n  \n          ```Python\n          heroes = await session.execute(select(Hero)).scalars().all()\n          ```\n  \n          instead you could use `exec()`:\n  \n          ```Python\n          heroes = await session.exec(select(Hero)).all()\n          ```\n          \n    result = await async_session.execute(

tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_email_failure
  C:\\Users\\DanielsFega\\legal-watch-dog-be\\tests\\modules\\v1\\notifications\\service\\test_ticket_notification_services.py:450: DeprecationWarning: \n          \U0001f6a8 You probably want to use `session.exec()` instead of `session.execute()`.\n  \n          This is the original SQLAlchemy `session.execute()` method that returns objects\n          of type `Row`, and that you have to call `scalars()` to get the model objects.\n  \n          For example:\n  \n          ```Python\n          heroes = await session.execute(select(Hero)).scalars().all()\n          ```\n  \n          instead you could use `exec()`:\n  \n          ```Python\n          heroes = await session.exec(select(Hero)).all()\n          ```\n          \n    result = await async_session.execute(select(TicketNotification))

tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_email_exception
  C:\\Users\\DanielsFega\\legal-watch-dog-be\\tests\\modules\\v1\\notifications\\service\\test_ticket_notification_services.py:497: DeprecationWarning: \n          \U0001f6a8 You probably want to use `session.exec()` instead of `session.execute()`.\n  \n          This is the original SQLAlchemy `session.execute()` method that returns objects\n          of type `Row`, and that you have to call `scalars()` to get the model objects.\n  \n          For example:\n  \n          ```Python\n          heroes = await session.execute(select(Hero)).scalars().all()\n          ```\n  \n          instead you could use `exec()`:\n  \n          ```Python\n          heroes = await session.exec(select(Hero)).all()\n          ```\n          \n    result = await async_session.execute(select(TicketNotification))

tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_not_found
  C:\\Users\\DanielsFega\\legal-watch-dog-be\\tests\\modules\\v1\\notifications\\service\\test_ticket_notification_services.py:514: DeprecationWarning: \n          \U0001f6a8 You probably want to use `session.exec()` instead of `session.execute()`.\n  \n          This is the original SQLAlchemy `session.execute()` method that returns objects\n          of type `Row`, and that you have to call `scalars()` to get the model objects.\n  \n          For example:\n  \n          ```Python\n          heroes = await session.execute(select(Hero)).scalars().all()\n          ```\n  \n          instead you could use `exec()`:\n  \n          ```Python\n          heroes = await session.exec(select(Hero)).all()\n          ```\n          \n    result = await async_session.execute(select(TicketNotification))

tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_empty_message
  C:\\Users\\DanielsFega\\legal-watch-dog-be\\tests\\modules\\v1\\notifications\\service\\test_ticket_notification_services.py:629: DeprecationWarning: \n          \U0001f6a8 You probably want to use `session.exec()` instead of `session.execute()`.\n  \n          This is the original SQLAlchemy `session.execute()` method that returns objects\n          of type `Row`, and that you have to call `scalars()` to get the model objects.\n  \n          For example:\n  \n          ```Python\n          heroes = await session.execute(select(Hero)).scalars().all()\n          ```\n  \n          instead you could use `exec()`:\n  \n          ```Python\n          heroes = await session.exec(select(Hero)).all()\n          ```\n          \n    result = await async_session.execute(select(TicketNotification))

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_sends_emails_success
FAILED tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_only_creator
FAILED tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_duplicate_user_handling
FAILED tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_missing_user
FAILED tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_empty_message
FAILED tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_email_context
FAILED tests/modules/v1/notifications/service/test_ticket_notification_services.py::test_ticket_notification_different_statuses
============ 7 failed, 7 passed, 80 warnings in 279.17s (0:04:39) =============
